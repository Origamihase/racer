<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>COCKPIT RACER ULTRA</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #start-msg {
            background: rgba(0,0,0,0.8);
            color: #0ff;
            padding: 20px;
            border: 2px solid #0ff;
            font-size: 20px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
        }
        #controls {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            display: flex;
        }
        .touch-zone { flex: 1; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div id="start-msg" onclick="startGame()">
        SYSTEM BEREIT.<br><br>
        [ KLICKEN ZUM STARTEN ]<br><br>
        <span style="font-size:14px">Steuerung: Pfeiltasten oder Touch (Links/Rechts)</span>
    </div>
</div>

<div id="controls">
    <div class="touch-zone" id="btnLeft"></div>
    <div class="touch-zone" id="btnRight"></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startMsg = document.getElementById('start-msg');

    // --- EINSTELLUNGEN ---
    const CFG = {
        fps: 60,
        segments: 2000,
        rumbleLength: 3,
        roadWidth: 2000,
        lanes: 3,
        fov: 100,
        cameraHeight: 1000,
        cameraDepth: 0.8,
        drawDistance: 300,
        fogDensity: 5,
        speedLimit: 260
    };

    // --- SPIELSTATUS ---
    let state = {
        running: false,
        time: 0,
        position: 0,
        playerX: 0,
        speed: 0,
        rainIntensity: 0,
        isRaining: false,
        wiperError: false,
        wiperAngle: 0,
        score: 0,
        lastLaneChange: 0
    };

    let segments = [];
    let keys = { left: false, right: false, up: false, down: false };

    // --- INITIALISIERUNG ---
    function init() {
        resize();
        createRoad();
        // Wir warten auf User-Input zum Starten
    }

    function startGame() {
        startMsg.style.display = 'none';
        state.running = true;
        loop();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function createRoad() {
        segments = [];
        for (let i = 0; i < CFG.segments; i++) {
            // Kurven generieren
            let curve = 0;
            if (i > 300 && i < 700) curve = 2;
            if (i > 1100 && i < 1600) curve = -2;
            if (i > 1800) curve = 4;

            // Spurwechsel Events (visuell durch Breite simuliert)
            let lanes = 3;
            if (i > 1000 && i < 1500) lanes = 2; // Baustelle

            segments.push({
                index: i,
                p1: { world: { z: i * 200 }, camera: {}, screen: {} },
                p2: { world: { z: (i + 1) * 200 }, camera: {}, screen: {} },
                curve: curve,
                lanes: lanes,
                color: Math.floor(i / CFG.rumbleLength) % 2 ? 
                    { road: '#333', grass: '#111', rumble: '#555', lane: '#fff' } : 
                    { road: '#303030', grass: '#0d0d0d', rumble: '#333', lane: '#000' }
            });
        }
    }

    // --- PHYSIK & LOGIK ---
    function update(dt) {
        state.time += dt;

        // Wetter Zyklus (Alle 15 Sekunden Wechsel)
        if (state.time % 30 > 20) {
            state.isRaining = true;
            state.wiperError = true; // Defekt simulieren
            if(state.rainIntensity < 1) state.rainIntensity += dt * 0.5;
        } else {
            state.isRaining = false;
            state.wiperError = false;
            if(state.rainIntensity > 0) state.rainIntensity -= dt * 0.5;
        }

        // Steuerung
        let speedRatio = state.speed / CFG.speedLimit;
        let dx = dt * 2 * speedRatio;

        if (keys.left) state.playerX -= dx;
        if (keys.right) state.playerX += dx;
        
        // Gasgeben / Bremsen (Automatik-Beschleunigung wenn nicht gebremst)
        if (keys.up) state.speed += dt * 100; // Turbo
        else if (keys.down) state.speed -= dt * 200; // Bremse
        else state.speed += dt * 20; // Langsames Beschleunigen (Standgas)

        // Reibung & Limits
        state.speed = Math.max(0, Math.min(state.speed, CFG.speedLimit));
        if (state.playerX < -2 || state.playerX > 2) state.speed -= dt * 150; // Offroad bremst

        // Bewegung
        state.position += state.speed * dt * 2.5; // Skalierung der Geschwindigkeit
        while (state.position >= CFG.segments * 200) state.position -= CFG.segments * 200;
        while (state.position < 0) state.position += CFG.segments * 200;
    }

    // --- GRAFIK ENGINE ---
    function project(p, cameraX, cameraY, cameraZ, width, height, roadWidth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        
        // Z-Clipping verhindern (keine Division durch 0 oder negative Werte)
        if (p.camera.z < 1) {
            p.screen.scale = 0;
        } else {
            p.screen.scale = CFG.cameraDepth / p.camera.z;
        }

        p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
        p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
        p.screen.w = Math.round((p.screen.scale * roadWidth * width / 2));
    }

    function drawPoly(x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.lineTo(x4, y4);
        ctx.fill();
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. HIMMEL
        let skyTop = state.isRaining ? '#1a1a1a' : '#001133';
        let skyBot = state.isRaining ? '#333333' : '#440044';
        let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, skyTop);
        grad.addColorStop(1, skyBot);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. STRASSE
        let baseIdx = Math.floor(state.position / 200) % CFG.segments;
        let startPos = state.position;
        let camH = CFG.cameraHeight + Math.sin(state.time * 10) * (state.speed / 20); // Wackeln

        let x = 0, dx = 0;
        let maxY = canvas.height;

        for (let n = 0; n < CFG.drawDistance; n++) {
            let idx = (baseIdx + n) % CFG.segments;
            let segment = segments[idx];
            
            // Loop-Logik für Z-Koordinaten
            let looped = segment.index < baseIdx;
            let loopOffset = looped ? CFG.segments * 200 : 0;
            
            // Projektion
            project(segment.p1, (state.playerX * CFG.roadWidth) - x, camH, startPos - loopOffset, canvas.width, canvas.height, CFG.roadWidth);
            project(segment.p2, (state.playerX * CFG.roadWidth) - x - dx, camH, startPos - loopOffset, canvas.width, canvas.height, CFG.roadWidth);

            x += dx;
            dx += segment.curve;

            if (segment.p1.camera.z <= CFG.cameraDepth || segment.p2.screen.y >= maxY || segment.p2.screen.y >= segment.p1.screen.y) {
                continue;
            }

            drawPoly(0, segment.p2.screen.y, canvas.width, segment.p2.screen.y, canvas.width, segment.p1.screen.y, 0, segment.p1.screen.y, segment.color.grass);
            drawPoly(segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y, segment.p2.screen.x, segment.p2.screen.y, segment.color.road);

            // Markierungen
            let lanes = segment.lanes;
            let w1 = segment.p1.screen.w / 20;
            let w2 = segment.p2.screen.w / 20;
            
            // Fahrbahnstreifen
            if ((segment.index + (baseIdx % 2)) % 2) {
                for(let j=1; j<lanes; j++) {
                    let l1 = segment.p1.screen.x + (segment.p1.screen.w * j / lanes);
                    let l2 = segment.p2.screen.x + (segment.p2.screen.w * j / lanes);
                    drawPoly(l1 - w1/4, segment.p1.screen.y, l1 + w1/4, segment.p1.screen.y, l2 + w2/4, segment.p2.screen.y, l2 - w2/4, segment.p2.screen.y, segment.color.lane);
                }
            }

            // Rumble Strips (Seitenstreifen)
            drawPoly(segment.p1.screen.x - w1, segment.p1.screen.y, segment.p1.screen.x, segment.p1.screen.y, segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.x - w2, segment.p2.screen.y, segment.color.rumble);
            drawPoly(segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w + w1, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w + w2, segment.p2.screen.y, segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y, segment.color.rumble);

            maxY = segment.p2.screen.y;
        }

        // 3. REGEN EFFEKT
        if (state.rainIntensity > 0) {
            ctx.fillStyle = `rgba(200, 200, 220, ${state.rainIntensity * 0.3})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Nebel
            
            ctx.strokeStyle = `rgba(255, 255, 255, ${state.rainIntensity * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0; i<50; i++) {
                let rx = Math.random() * canvas.width;
                let ry = Math.random() * canvas.height;
                ctx.moveTo(rx, ry);
                ctx.lineTo(rx - 10, ry + 20);
            }
            ctx.stroke();
        }

        // 4. COCKPIT (Zeichnung)
        drawCockpit();
    }

    function drawCockpit() {
        let w = canvas.width;
        let h = canvas.height;
        let dashH = h * 0.3;

        // Armaturenbrett Körper
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(0, h);
        ctx.lineTo(0, h - dashH + 50);
        ctx.quadraticCurveTo(w * 0.2, h - dashH, w * 0.5, h - dashH);
        ctx.quadraticCurveTo(w * 0.8, h - dashH, w, h - dashH + 50);
        ctx.lineTo(w, h);
        ctx.fill();
        
        // Naht
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.stroke();

        // TACHO (Links)
        drawGauge(w * 0.25, h - 50, state.speed, 0, 300, "KM/H", false);
        
        // DREHZAHL (Rechts)
        drawGauge(w * 0.75, h - 50, state.speed * 30 + Math.random()*500, 0, 9000, "RPM", true);

        // WARNLEUCHTE (Mitte)
        if (state.wiperError) {
            // Blinken
            if (Math.floor(Date.now() / 300) % 2 === 0) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'red';
                ctx.beginPath();
                ctx.arc(w * 0.5, h - dashH + 40, 10, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#ffcccc';
                ctx.font = '10px sans-serif';
                ctx.fillText("WIPER", w * 0.5 - 15, h - dashH + 25);
            }
        }

        // LENKRAD
        ctx.save();
        ctx.translate(w * 0.5, h + 80);
        ctx.rotate(state.playerX * 0.8); // Rotation basierend auf Position
        
        // Lenkradkranz
        ctx.lineWidth = 20;
        ctx.strokeStyle = '#333';
        ctx.beginPath();
        ctx.arc(0, 0, 120, 0, Math.PI*2);
        ctx.stroke();
        
        // Speichen
        ctx.fillStyle = '#444';
        ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-110, 20); ctx.lineTo(-20, 40); ctx.fill();
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(110, 20); ctx.lineTo(20, 40); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-15, 20); ctx.lineTo(0, 110); ctx.lineTo(15, 20); ctx.fill();
        
        // Mitte Logo
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
        
        ctx.restore();
    }

    function drawGauge(x, y, val, min, max, label, isRpm) {
        let radius = 60;
        if (window.innerWidth < 500) radius = 40; // Kleiner auf Handy

        ctx.fillStyle = '#000';
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI*2); ctx.fill(); ctx.stroke();

        // Skala
        let percent = (val - min) / (max - min);
        let angle = Math.PI * 0.8 + (percent * (Math.PI * 1.4));
        
        ctx.strokeStyle = isRpm && percent > 0.8 ? 'red' : '#00ffff';
        ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(x, y, radius - 10, Math.PI * 0.8, angle); ctx.stroke();

        // Text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px monospace';
        ctx.fillText(Math.floor(val), x - 10, y + 10);
        ctx.font = '10px monospace';
        ctx.fillText(label, x - 15, y + 25);
    }

    // --- GAME LOOP & INPUT ---
    let lastTime = 0;
    function loop(time) {
        if (!state.running) return;
        if (!lastTime) lastTime = time;
        let dt = (time - lastTime) / 1000;
        lastTime = time;

        try {
            update(Math.min(dt, 0.1)); // Max dt limit
            render();
            requestAnimationFrame(loop);
        } catch (e) {
            state.running = false;
            alert("Fehler im Rendering: " + e.message);
            console.error(e);
        }
    }

    // Input Event Listeners
    window.addEventListener('keydown', e => {
        if(e.code === 'ArrowLeft') keys.left = true;
        if(e.code === 'ArrowRight') keys.right = true;
        if(e.code === 'ArrowUp') keys.up = true;
        if(e.code === 'ArrowDown') keys.down = true;
    });
    window.addEventListener('keyup', e => {
        if(e.code === 'ArrowLeft') keys.left = false;
        if(e.code === 'ArrowRight') keys.right = false;
        if(e.code === 'ArrowUp') keys.up = false;
        if(e.code === 'ArrowDown') keys.down = false;
    });

    // Touch
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
    btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys.left = false; });
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
    btnRight.addEventListener('touchend', (e) => { e.preventDefault(); keys.right = false; });

    window.addEventListener('resize', resize);
    
    // Start
    init();

</script>
</body>
</html>
