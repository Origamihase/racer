<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NIGHT RACER: VISUAL BOOST</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            background: rgba(0,0,0,0.6);
            transition: opacity 0.5s;
        }
        #start-card {
            background: linear-gradient(135deg, #1a0b2e 0%, #000000 100%);
            border: 2px solid #00ffcc;
            box-shadow: 0 0 30px #00ffcc, inset 0 0 50px rgba(0, 255, 204, 0.1);
            padding: 40px 60px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            transform: skew(-10deg);
            position: relative;
            overflow: hidden;
        }
        h1 { 
            margin: 0; font-size: 72px; color: #fff; 
            font-style: italic; text-transform: uppercase; 
            text-shadow: 4px 4px 0px #ff0055;
            line-height: 0.9;
        }
        h2 {
            margin: 0 0 20px 0; font-size: 24px; color: #00ffcc;
            letter-spacing: 5px; text-transform: uppercase;
        }
        .blink { animation: blink 0.8s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }

        /* Touch Controls */
        #controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; display: flex;
        }
        .zone { flex: 1; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div id="start-card" onclick="startGame()">
        <h1>Night<br>Racer</h1>
        <h2>Visual Boost</h2>
        <p class="blink" style="color:white; font-weight:bold; font-size:20px;">CLICK TO START</p>
    </div>
</div>

<div id="controls">
    <div class="zone" id="btnLeft"></div>
    <div class="zone" id="btnRight"></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const uiLayer = document.getElementById('ui-layer');

    let width, height;
    
    // --- SETTINGS ---
    const CFG = {
        segmentLength: 200,
        rumbleLength: 3,
        roadWidth: 2000,
        lanes: 3,
        fov: 100,
        cameraHeight: 1000,
        cameraDepth: 0.84,
        drawDistance: 300,
        speedLimit: 420,
        accel: 180,
        breaking: -300,
        decel: -20,
        offRoadDecel: -150,
        offRoadLimit: 80,
        centrifugal: 0.09,
        skyTop: '#000011',
        skyBot: '#220033'
    };

    // --- STATE ---
    let state = {
        running: false,
        position: 0,
        playerX: 0,
        speed: 0,
        time: 0,
        bgOffset: 0,
        rain: 0,
        isRaining: false,
        wiperPos: 0,
        wiperBroken: true,
        score: 0,
        turbo: 0
    };

    let keys = { left: false, right: false, up: false, down: false };
    let segments = [];
    let cars = []; 

    // --- INIT ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function resetRoad() {
        segments = [];
        // Endlos wirkende Strecke generieren
        for (let n = 0; n < 4000; n++) {
            let curve = 0;
            let y = 0;
            
            // Kurven
            if (n > 200 && n < 500) curve = 2;
            if (n > 600 && n < 1100) curve = -3;
            if (n > 1300 && n < 1700) curve = 4;
            if (n > 1900 && n < 2300) curve = -2;
            if (n > 2500 && n < 3000) curve = 3;
            if (n > 3200 && n < 3800) curve = -4;

            // Hügel
            if (n > 800 && n < 1600) y = Math.sin(n/50) * 1500;
            if (n > 2200 && n < 2800) y = Math.cos(n/50) * 1500;

            let color = Math.floor(n / CFG.rumbleLength) % 2 ? 
                { road: '#111', grass: '#0a0014', rumble: '#00ffcc', lane: '#fff' } : 
                { road: '#111', grass: '#05000a', rumble: '#0099aa', lane: '#000' };

            segments.push({
                index: n,
                p1: { world: { y: y, z: n * CFG.segmentLength }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (n + 1) * CFG.segmentLength }, camera: {}, screen: {} },
                curve: curve,
                color: color
            });
        }

        // Verkehr
        cars = [];
        for (let n = 0; n < 150; n++) {
            let offset = Math.floor(Math.random() * 3800) + 200;
            // Farben für Autos
            const carColors = ['#cc0000', '#0033cc', '#00cc44', '#eeeeee', '#ccaa00'];
            let col = carColors[Math.floor(Math.random() * carColors.length)];

            // Lanes entlang der Straßenbreite verteilen
            const laneIndex = Math.floor(Math.random() * CFG.lanes);
            const laneNormalized = (laneIndex / (CFG.lanes - 1)) * 2 - 1; // -1 links, 0 Mitte, 1 rechts
            const laneJitter = (Math.random() * 0.2) - 0.1;

            cars.push({
                z: offset * CFG.segmentLength,
                speed: 120 + Math.random() * 150,
                lane: laneNormalized + laneJitter,
                type: Math.random() > 0.7 ? 'truck' : 'sport',
                color: col
            });
        }
    }

    function startGame() {
        uiLayer.style.opacity = '0';
        setTimeout(() => uiLayer.style.display = 'none', 500);
        state.running = true;
        keys.up = true; // Auto-Start
        requestAnimationFrame(loop);
    }

    // --- LOGIK ---
    function update(dt) {
        state.time += dt;
        state.score += (state.speed * dt) / 10;

        // Wetter
        if ((state.time % 40) > 25) { 
            state.isRaining = true;
            if(state.rain < 1) state.rain += dt * 0.5;
        } else {
            state.isRaining = false;
            if(state.rain > 0) state.rain -= dt * 0.5;
        }

        // Scheibenwischer (Defekt)
        if (state.isRaining || state.wiperPos > 0.1) {
            let target = 0.3;
            if ((state.time * 10) % 20 > 18) target = 0.5;
            let force = (target - state.wiperPos) * dt * 5;
            state.wiperPos += force;
        } else {
            state.wiperPos = 0;
        }

        // Physik
        let maxSpeed = CFG.speedLimit;
        if (state.rain > 0.5) maxSpeed = 380; 

        let accel = keys.up ? CFG.accel : (keys.down ? CFG.breaking : CFG.decel);
        state.speed += accel * dt;
        state.speed = Math.max(0, Math.min(state.speed, maxSpeed));

        // Turbo
        if(state.speed > 350) state.turbo = Math.min(1, state.turbo + dt);
        else state.turbo = Math.max(0, state.turbo - dt);

        // Steuerung
        let speedRatio = state.speed / CFG.speedLimit;
        // Mehr direktes Lenkgefühl, besonders bei höheren Geschwindigkeiten
        let dx = dt * (2.4 + (speedRatio * 1.6));
        
        if (keys.left) state.playerX -= dx;
        if (keys.right) state.playerX += dx;

        // Kurven
        let segIdx = Math.floor(state.position / CFG.segmentLength) % segments.length;
        if (segIdx < 0) segIdx += segments.length;
        let currentSegment = segments[segIdx];

        if (currentSegment && speedRatio > 0) {
             state.playerX -= (dx * speedRatio * currentSegment.curve * CFG.centrifugal);
             state.bgOffset -= currentSegment.curve * speedRatio * dt * 0.8;
        }

        // Kollision
        for(let car of cars) {
            car.z += car.speed * dt * 1.5;
            let maxZ = segments.length * CFG.segmentLength;
            if (car.z > maxZ) car.z -= maxZ;

            let dist = car.z - state.position;
            if (dist < -maxZ/2) dist += maxZ;
            if (dist > maxZ/2) dist -= maxZ;

            if (dist > 0 && dist < 280) {
                // Normalisiere Spieler-Lateralposition auf Lane-Koordinaten
                const playerLane = Math.max(-1, Math.min(1, state.playerX / 3));
                const laneDelta = Math.abs(playerLane - car.lane);

                if (laneDelta < 0.45) {
                    if (state.speed > car.speed) {
                        state.speed = car.speed * 0.8;
                        CFG.cameraHeight = 900 + Math.random()*200;
                    }
                }
            }
        }

        // Offroad
        if ((state.playerX < -2.2 || state.playerX > 2.2) && state.speed > CFG.offRoadLimit) {
            state.speed += CFG.offRoadDecel * dt;
        }
        state.playerX = Math.max(-3.5, Math.min(3.5, state.playerX));

        // Camera Shake
        let shake = (state.speed > 200) ? (state.speed/400) * 5 : 0;
        CFG.cameraHeight = 1000 + (Math.random() * shake * 20) + Math.sin(state.time * 10)*shake*10;

        // Move
        // Höhere Übersetzung in die Kamerabewegung sorgt für sichtbar mehr Tempo
        state.position += state.speed * dt * 3.5;
        let trackLen = segments.length * CFG.segmentLength;
        while (state.position >= trackLen) state.position -= trackLen;
        while (state.position < 0) state.position += trackLen;
    }

    // --- RENDER ---
    function project(p, cameraX, cameraY, cameraZ, depth) {
        p.camera.x = (p.world.x || 0) - cameraX;
        p.camera.y = (p.world.y || 0) - cameraY;
        p.camera.z = (p.world.z || 0) - cameraZ;
        if (p.camera.z < 1) { p.screen.scale = 0; return; }
        
        p.screen.scale = depth / p.camera.z;
        p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
        p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
        p.screen.w = Math.round((p.screen.scale * CFG.roadWidth * width / 2));
    }

    function drawPoly(x1, y1, x2, y2, x3, y3, x4, y4, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.lineTo(x4, y4);
        ctx.fill();
    }

    function render() {
        ctx.clearRect(0, 0, width, height);

        // HIMMEL
        let grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, CFG.skyTop);
        grad.addColorStop(1, CFG.skyBot);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        // Sterne
        if (!state.isRaining) {
            ctx.fillStyle = '#fff';
            for(let i=0; i<50; i++) {
                let sx = (i * 137 + state.bgOffset * 20) % width;
                if(sx < 0) sx += width;
                let sy = (i * 97) % (height/2);
                ctx.fillRect(sx, sy, 2, 2);
            }
        }

        // Berge
        drawHills(0.002, 30, '#0a001a', 150);
        drawHills(0.01, 60, '#140028', 80);

        // STRASSE
        let startPos = state.position;
        let baseIdx = Math.floor(startPos / CFG.segmentLength);
        let maxy = height;
        let x = 0, dx = 0;

        for (let n = 0; n < CFG.drawDistance; n++) {
            let idx = (baseIdx + n) % segments.length;
            if (idx < 0) idx += segments.length;
            let segment = segments[idx];
            if(!segment) continue;

            let looped = segment.index < baseIdx;
            let loopOffset = looped ? segments.length * CFG.segmentLength : 0;
            let camZ = startPos - loopOffset;

            project(segment.p1, (state.playerX * CFG.roadWidth) - x, CFG.cameraHeight, camZ, CFG.cameraDepth);
            project(segment.p2, (state.playerX * CFG.roadWidth) - x - dx, CFG.cameraHeight, camZ, CFG.cameraDepth);

            x += dx;
            dx += segment.curve;

            if (segment.p1.camera.z <= CFG.cameraDepth || segment.p2.screen.y >= maxy || segment.p2.screen.y >= segment.p1.screen.y) continue;

            // Grass & Road
            drawPoly(0, segment.p2.screen.y, width, segment.p2.screen.y, width, segment.p1.screen.y, 0, segment.p1.screen.y, segment.color.grass);
            drawPoly(segment.p1.screen.x, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y, 
                     segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y, segment.p2.screen.x, segment.p2.screen.y, 
                     segment.color.road);

            // Rumble
            let w1 = segment.p1.screen.w / 20;
            let w2 = segment.p2.screen.w / 20;
            drawPoly(segment.p1.screen.x - w1, segment.p1.screen.y, segment.p1.screen.x, segment.p1.screen.y, segment.p2.screen.x, segment.p2.screen.y, segment.p2.screen.x - w2, segment.p2.screen.y, segment.color.rumble);
            drawPoly(segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y, segment.p1.screen.x + segment.p1.screen.w + w1, segment.p1.screen.y, segment.p2.screen.x + segment.p2.screen.w + w2, segment.p2.screen.y, segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y, segment.color.rumble);

            // Lanes
            if ((segment.index + (baseIdx%2))%2) {
                 let l1 = segment.p1.screen.w / CFG.lanes;
                 let l2 = segment.p2.screen.w / CFG.lanes;
                 for(let j=1; j<CFG.lanes; j++) {
                     drawPoly(segment.p1.screen.x + l1*j - w1/5, segment.p1.screen.y, segment.p1.screen.x + l1*j + w1/5, segment.p1.screen.y,
                              segment.p2.screen.x + l2*j + w2/5, segment.p2.screen.y, segment.p2.screen.x + l2*j - w2/5, segment.p2.screen.y, segment.color.lane);
                 }
            }

            // AUTOS
            let segZ = segment.index * CFG.segmentLength;
            for(let c of cars) {
                let cZ = c.z;
                if (looped && cZ < startPos) cZ += segments.length * CFG.segmentLength;

                if (cZ >= segZ && cZ < segZ + CFG.segmentLength) {
                    let percent = (cZ - segZ) / CFG.segmentLength;
                    if (segment.p1.screen.scale === 0 || segment.p2.screen.scale === 0) continue;

                    // Interpoliere Position und Breite der Straße
                    let carY = segment.p1.screen.y + (segment.p2.screen.y - segment.p1.screen.y) * percent;
                    let roadW = segment.p1.screen.w + (segment.p2.screen.w - segment.p1.screen.w) * percent;
                    let roadX = segment.p1.screen.x + (segment.p2.screen.x - segment.p1.screen.x) * percent;
                    let roadCenter = roadX + roadW * 0.5;

                    // Sanfte Skalierung abhängig von Straßentiefe
                    let scale = segment.p1.screen.scale + (segment.p2.screen.scale - segment.p1.screen.scale) * percent;
                    let carW = Math.max(30, roadW * 0.6);
                    let carH = Math.max(20, carW * (c.type === 'truck' ? 0.75 : 0.55));

                    // X Position anhand Lane-Koordinaten berechnen
                    let laneOffset = c.lane * roadW * 0.45;
                    let carX = roadCenter + laneOffset;

                    // Zeichne Auto
                    drawCar(carX, carY, carW, carH, c.color, c.type);
                }
            }
            maxy = segment.p2.screen.y;
        }

        // Speed Lines
        if (state.turbo > 0.1) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${state.turbo * 0.3})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0; i<10; i++) {
                let lx = width/2 + (Math.random()-0.5)*width*2;
                let ly = height/2 + (Math.random()-0.5)*height*2;
                ctx.moveTo(width/2, height/2);
                ctx.lineTo(lx, ly);
            }
            ctx.stroke();
        }

        // Regen
        if (state.rain > 0) {
            ctx.fillStyle = `rgba(0,0,20,${state.rain * 0.25})`;
            ctx.fillRect(0,0,width,height);
            ctx.strokeStyle = `rgba(200,255,255,${state.rain * 0.6})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let i=0; i<80*state.rain; i++) {
                let rx = Math.random()*width;
                let ry = Math.random()*height;
                ctx.moveTo(rx,ry);
                ctx.lineTo(rx - (state.speed*0.15), ry + 30);
            }
            ctx.stroke();
        }

        drawWiper();
        drawCockpit();
    }

    // --- HELPER: DRAW CAR ---
    function drawCar(x, y, w, h, color, type) {
        // y ist der Bodenpunkt auf dem Screen
        let bodyH = h * 0.6;
        let roofH = h * 0.4;
        let bottomY = y;

        // Schatten
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(x - w*0.55, bottomY - h*0.1, w*1.1, h*0.1);

        // Reifen
        ctx.fillStyle = '#111';
        ctx.fillRect(x - w*0.45, bottomY - bodyH*0.5, w*0.15, bodyH*0.5);
        ctx.fillRect(x + w*0.30, bottomY - bodyH*0.5, w*0.15, bodyH*0.5);

        // Body
        ctx.fillStyle = color;
        ctx.fillRect(x - w/2, bottomY - bodyH, w, bodyH);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - w/2, bottomY - bodyH, w, bodyH);
        
        // Dach (Schmaler)
        let roofW = w * (type === 'truck' ? 0.9 : 0.6);
        ctx.fillStyle = shadeColor(color, -20); // Dunkler
        ctx.fillRect(x - roofW/2, bottomY - bodyH - roofH, roofW, roofH);

        // Heckscheibe
        ctx.fillStyle = '#220033'; // Dunkles Glas
        ctx.fillRect(x - roofW*0.4, bottomY - bodyH - roofH*0.8, roofW*0.8, roofH*0.6);

        // Rücklichter (Leuchtend)
        let lw = w * 0.15; 
        let lh = bodyH * 0.3;
        let ly = bottomY - bodyH * 0.6;
        
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.fillRect(x - w*0.4, ly, lw, lh);
        ctx.fillRect(x + w*0.25, ly, lw, lh);
        ctx.shadowBlur = 0;

        // Lichtschein auf Straße
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(x - w*0.3, bottomY + 5, lw, 0, Math.PI*2);
        ctx.arc(x + w*0.3, bottomY + 5, lw, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    function shadeColor(color, percent) {
        // Hex-Farbe um Prozentwert abdunkeln/aufhellen
        const num = parseInt(color.replace('#',''), 16);
        const amt = Math.round(2.55 * percent);
        const r = Math.max(0, Math.min(255, (num >> 16) + amt));
        const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
        const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
        return `#${(1 << 24 | (r << 16) | (g << 8) | b).toString(16).slice(1)}`;
    }

    function drawHills(speedMod, yOff, color, hVar) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(0, height/2);
        for(let i=0; i<=width; i+=10) {
            let h = Math.sin((i + state.bgOffset * speedMod * 2000) * 0.003) * hVar;
            h += Math.cos((i + state.bgOffset * speedMod * 500) * 0.01) * (hVar/3);
            ctx.lineTo(i, (height/2) - yOff - h);
        }
        ctx.lineTo(width, height/2);
        ctx.fill();
    }

    function drawWiper() {
        let angle = -Math.PI/4 + (state.wiperPos * (Math.PI/2));
        let px = width / 2;
        let py = height + 50;
        
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(angle);
        ctx.fillStyle = '#111';
        ctx.fillRect(-10, -height*1.3, 20, height*1.3);
        ctx.restore();
    }

    function drawCockpit() {
        let dashH = height * 0.2;
        let y = height - dashH;

        // Dashboard
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(0, height);
        ctx.lineTo(0, y+20);
        ctx.lineTo(width*0.25, y);
        ctx.lineTo(width*0.75, y);
        ctx.lineTo(width, y+20);
        ctx.lineTo(width, height);
        ctx.fill();

        ctx.strokeStyle = '#ff0055';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, y+20);
        ctx.lineTo(width*0.25, y);
        ctx.lineTo(width*0.75, y);
        ctx.lineTo(width, y+20);
        ctx.stroke();

        // Tacho
        let tx = width * 0.5;
        let ty = height - 50;
        let barW = 300;
        let barH = 10;
        let fill = (state.speed / CFG.speedLimit);
        ctx.fillStyle = '#333';
        ctx.fillRect(tx - barW/2, ty - 60, barW, barH);
        ctx.fillStyle = fill > 0.9 ? '#ff0055' : '#00ffcc';
        ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
        ctx.fillRect(tx - barW/2, ty - 60, barW * fill, barH);
        ctx.shadowBlur = 0;

        ctx.font = 'italic bold 60px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#fff';
        ctx.fillText(Math.floor(state.speed), tx, ty + 20);
        ctx.font = '16px sans-serif';
        ctx.fillStyle = '#aaa';
        ctx.fillText("KM/H", tx, ty + 45);

        ctx.textAlign = 'left';
        ctx.font = '20px monospace';
        ctx.fillStyle = '#00ffcc';
        ctx.fillText("SCORE: " + Math.floor(state.score), 20, 40);

        // Lenkrad
        let lx = width * 0.25;
        let ly = height + 40;
        let rot = state.playerX * 0.5;
        ctx.save();
        ctx.translate(lx, ly);
        ctx.rotate(rot);
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.moveTo(-60, -40); ctx.lineTo(60, -40);
        ctx.lineTo(60, 40); ctx.lineTo(40, 60);
        ctx.lineTo(-40, 60); ctx.lineTo(-60, 40);
        ctx.fill();
        ctx.fillStyle = '#333';
        ctx.fillRect(-70, -20, 20, 60);
        ctx.fillRect(50, -20, 20, 60);
        ctx.restore();

        // Warnleuchte
        if (state.wiperBroken && state.isRaining) {
            let wx = width * 0.75;
            let wy = y + 30;
            let blink = Math.floor(state.time * 8) % 2 === 0;
            
            ctx.fillStyle = blink ? '#ff3300' : '#440000';
            ctx.shadowBlur = blink ? 20 : 0; 
            ctx.shadowColor = 'red';
            ctx.beginPath();
            ctx.moveTo(wx, wy);
            ctx.lineTo(wx + 20, wy + 35);
            ctx.lineTo(wx - 20, wy + 35);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            if(blink) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText("!", wx, wy + 30);
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#ff3300';
                ctx.fillText("ERROR", wx, wy - 10);
            }
        }
    }

    let lastTime = 0;
    function loop(timestamp) {
        if(!state.running) return;
        if(!lastTime) lastTime = timestamp;
        let dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if(dt > 0.1) dt = 0.1;

        update(dt);
        render();
        requestAnimationFrame(loop);
    }

    const handleKey = (code, val, event) => {
        const handled = code === 'ArrowLeft' || code === 'ArrowRight' || code === 'ArrowUp' || code === 'ArrowDown';
        if (!handled) return;

        if(code==='ArrowLeft') keys.left = val;
        if(code==='ArrowRight') keys.right = val;
        if(code==='ArrowUp') keys.up = val;
        if(code==='ArrowDown') keys.down = val;

        if (handled && event?.preventDefault) event.preventDefault();
    };
    window.addEventListener('keydown', e => handleKey(e.code, true, e));
    window.addEventListener('keyup', e => handleKey(e.code, false, e));

    const touchZone = (id, k) => {
        const el = document.getElementById(id);
        const opts = { passive: false };
        el.addEventListener('touchstart', e => { e.preventDefault(); keys[k]=true; }, opts);
        el.addEventListener('touchend', e => { e.preventDefault(); keys[k]=false; }, opts);
    };
    touchZone('btnLeft', 'left');
    touchZone('btnRight', 'right');

    resetRoad();

</script>
</body>
</html>
